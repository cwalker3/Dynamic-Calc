nature = {"Hardy","Lonely","Brave","Adamant","Naughty",
			"Bold","Docile","Relaxed","Impish","Lax",
			"Timid","Hasty","Serious","Jolly","Naive",
			"Modest","Mild","Quiet","Bashful","Rash",
			"Calm","Gentle","Sassy","Careful","Quirky"}

item = {'Master Ball',
'Ultra Ball',
'Great Ball',
'Poke Ball', 
'Safari Ball',
'Net Ball',   
'Dive Ball',
'Nest Ball',  
'Repeat Ball',
'Timer Ball', 
'Luxury Ball',
'Premier Ball',
' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
'Energy Powder',
' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
'Berry Juice',
' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
'Sun Stone',
'Moon Stone',
'Fire Stone',
'Thunder Stone',
'Water Stone',
'Leaf Stone',
' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
'Cheri Berry',
'Chesto Berry',
'Pecha Berry',
'Rawst Berry',
'Aspear Berry',
'Leppa Berry',
'Oran Berry',
'Persim Berry',
'Lum Berry',
'Sitrus Berry',
'Figy Berry',
'Wiki Berry',
'Mago Berry',
'Aguav Berry',
'Iapapa Berry',
'Razz Berry',
'Bluk Berry',
'Nanab Berry',
'Wepear Berry',
'Pinap Berry',
'Pomeg Berry',
'Kelpsy Berry',
'Qualot Berry',
'Hondew Berry',
'Grepa Berry',
'Tamato Berry',
'Cornn Berry',
'Magost Berry',
'Rabuta Berry',
'Nomel Berry',
'Spelon Berry',
'Pamtre Berry',
'Watmel Berry',
'Durin Berry',
'Belue Berry',
'Liechi Berry',
'Ganlon Berry',
'Salac Berry',
'Petaya Berry',
'Apicot Berry',
'Lansat Berry',
'Starf Berry',
'Enigma Berry',
' ',' ',' ',
'Bright Powder',
'White Herb',
'Macho Brace',
' ',
'Quick Claw',
' ',
'Mental Herb',
'Choice Band',
"King's Rock",
'Silver Powder',
' ',' ',
'Soul Dew',
'Deep Sea Tooth',
'Deep Sea Scale',
' ',' ',
'Focus Band',
' ',
'Scope Lens',
'Metal Coat',
'Leftovers',
'Dragon Scale',
'Light Ball',
'Soft Sand',
'Hard Stone',
'Miracle Seed',
'Black Glasses',
'Black Belt',
'Magnet',
'Mystic Water',
'Sharp Beak',
'Poison Barb',
'Never-Melt Ice',
'Spell Tag',
'Twisted Spoon',
'Charcoal',
'Dragon Fang',
'Silk Scarf',
'Up-Grade',
'Shell Bell',
'Sea Incense',
'Lax Incense',
'Lucky Punch',
'Metal Powder',
'Thick Club',
'Stick',
' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
'Red Orb',
'Blue Orb',
' ',' ',' ',' ',' ',' ',' ',' ',
'Root Fossil',
'Claw Fossil',
' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
'Old Amber',
' ',' ',
'Helix Fossil',
'Dome Fossil',
' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',}

move = {
'Pound',
'Karate Chop',
'Double Slap',
'Mirror Shot',
'Mega Punch',
'Pay Day',
'Fire Punch',
'Ice Punch',
'Thunder Punch',
'Scratch',
'Vise Grip',
'Throat Chop',
'Air Slash',
'Swords Dance',
'Cut',
'Gust',
'Wing Attack',
'Whirlwind',
'Fly',
'Hex',
'Slam',
'Vine Whip',
'Stomp',
'Double Kick',
'Mega Kick',
'Jump Kick',
'Rolling Kick',
'Sand Attack',
'Headbutt',
'Horn Attack',
'Fury Attack',
'Drill Run',
'Tackle',
'Body Slam',
'Wrap',
'Take Down',
'Thrash',
'Double-Edge',
'Tail Whip',
'Poison Sting',
'Twineedle',
'Pin Missile',
'Leer',
'Bite',
'Growl',
'Roar',
'Sing',
'Supersonic',
'Sonicboom',
'Disable',
'Acid',
'Ember',
'Flamethrower',
'Aqua Jet',
'Water Gun',
'Hydro Pump',
'Surf',
'Ice Beam',
'Blizzard',
'Psybeam',
'Bubble Beam',
'Aurora Beam',
'Hyper Beam',
'Peck',
'Drill Peck',
'Submission',
'Low Kick',
'Counter',
'Seismic Toss',
'Strength',
'Absorb',
'Mega Drain',
'Leech Seed',
'Growth',
'Razor Leaf',
'Solar Beam',
'Poison Powder',
'Stun Spore',
'Sleep Powder',
'Petal Dance',
'String Shot',
'Dragon Rage',
'Fire Spin',
'Thunder Shock',
'Thunderbolt',
'Thunder Wave',
'Thunder',
'Rock Throw',
'Earthquake',
'Earth Power',
'Dig',
'Toxic',
'Confusion',
'Psychic',
'Hypnosis',
'Meditate',
'Agility',
'Quick Attack',
'Rage',
'Teleport',
'Night Shade',
'Mimic',
'Screech',
'Double Team',
'Recover',
'Harden',
'Poison Jab',
'Smokescreen',
'Confuse Ray',
'Withdraw',
'Defense Curl',
'Barrier',
'Light Screen',
'Haze',
'Reflect',
'Focus Energy',
'Mud Bomb',
'Metronome',
'Mirror Move',
'Self-Destruct',
'Egg Bomb',
'Lick',
'Smog',
'Sludge',
'Bone Club',
'Fire Blast',
'Waterfall',
'Clamp',
'Swift',
'Iron Head',
'Spike Cannon',
'Bulldoze',
'Amnesia',
'Snarl',
'Soft-Boiled',
'High Jump Kick',
'Glare',
'Dream Eater',
'Poison Gas',
'Force Palm',
'Leech Life',
'Lovely Kiss',
'Sky Attack',
'Transform',
'Bubble',
'Dizzy Punch',
'Spore',
'Flash',
'Flash Cannon',
'Splash',
'Acid Armor',
'Crabhammer',
'Explosion',
'X-Scissor',
'Bonemerang',
'Rest',
'Rock Slide',
'Hyper Fang',
'Sharpen',
'Conversion',
'Tri Attack',
'Super Fang',
'Slash',
'Substitute',
'Struggle',
'Sketch',
'Aura Sphere',
'Thief',
'Spider Web',
'Dark Pulse',
'Nightmare',
'Flame Wheel',
'Snore',
'Curse',
'Flail',
'Conversion 2',
'Aeroblast',
'Cotton Spore',
'Reversal',
'Shadow Claw',
'Powder Snow',
'Protect',
'Mach Punch',
'Scary Face',
'Feint Attack',
'Sweet Kiss',
'Belly Drum',
'Sludge Bomb',
'Mud-Slap',
'Octazooka',
'Spikes',
'Gunk Shot',
'Foresight',
'Destiny Bond',
'Perish Song',
'Icy Wind',
'Detect',
'Bone Rush',
'Lock-On',
'Outrage',
'Sandstorm',
'Giga Drain',
'Endure',
'Charm',
'Rollout',
'False Swipe',
'Swagger',
'Milk Drink',
'Spark',
'Fury Cutter',
'Steel Wing',
'Mean Look',
'Attract',
'Sleep Talk',
'Heal Bell',
'Return',
'Present',
'Frustration',
'Safeguard',
'Pain Split',
'Sacred Fire',
'Magnitude',
'Dynamic Punch',
'Megahorn',
'Dragon Breath',
'Baton Pass',
'Encore',
'Pursuit',
'Rapid Spin',
'Sweet Scent',
'Iron Tail',
'Metal Claw',
'Vital Throw',
'Morning Sun',
'Synthesis',
'Moonlight',
'Hidden Power',
'Cross Chop',
'Twister',
'Rain Dance',
'Sunny Day',
'Crunch',
'Mirror Coat',
'Psych Up',
'Extreme Speed',
'Ancient Power',
'Shadow Ball',
'Zen Headbutt',
'Rock Smash',
'Whirlpool',
'Beat Up',
'Fake Out',
'Boomburst',
'Stockpile',
'Spit Up',
'Swallow',
'Heat Wave',
'Hail',
'Sucker Punch',
'Flatter',
'Will-O-Wisp',
'Memento',
'Facade',
'Focus Punch',
'Flame Burst',
'Follow Me',
'Nature Power',
'Charge',
'Taunt',
'Helping Hand',
'Trick',
'Scald',
'Wish',
'Assist',
'Ingrain',
'Superpower',
'Magic Coat',
'Recycle',
'Revenge',
'Brick Break',
'Yawn',
'Knock Off',
'Endeavor',
'Eruption',
'Skill Swap',
'Imprison',
'Refresh',
'Grudge',
'Power Gem',
'Secret Power',
'Dive',
'Arm Thrust',
'Camouflage',
'Tail Glow',
'Luster Purge',
'Mist Ball',
'Feather Dance',
'Teeter Dance',
'Blaze Kick',
'Icicle Crash',
'Ice Ball',
'Needle Arm',
'Slack Off',
'Hyper Voice',
'Poison Fang',
'Crush Claw',
'Blast Burn',
'Hydro Cannon',
'Meteor Mash',
'Astonish',
'Weather Ball',
'Aromatherapy',
'Fake Tears',
'Air Cutter',
'Overheat',
'Odor Sleuth',
'Rock Tomb',
'Silver Wind',
'Metal Sound',
'Grass Whistle',
'Tickle',
'Cosmic Power',
'Water Spout',
'Signal Beam',
'Shadow Punch',
'Extrasensory',
'Sky Uppercut',
'Sand Tomb',
'Sheer Cold',
'Muddy Water',
'Bullet Seed',
'Aerial Ace',
'Icicle Spear',
'Iron Defense',
'Block',
'Howl',
'Dragon Claw',
'Frenzy Plant',
'Bulk Up',
'Bounce',
'Mud Shot',
'Poison Tail',
'Covet',
'Wild Charge',
'Magical Leaf',
'Dragon Pulse',
'Calm Mind',
'Leaf Blade',
'Dragon Dance',
'Rock Blast',
'Shock Wave',
'Water Pulse',
'Doom Desire',
'Psycho Boost',
'Blood Drain',
'Sleep Bite',
'Hyper Tackle',
'Para Fang',
'Aqua Tail',
'Fire Lash',
'Discharge',
'Horn Leech',
'Wood Hammer',
'Dragon Pulse',
'Flak Fire',
'Diving Claw',
'Sleeping Gas',
'Steel Strike',
'Aqua Fist',
'Psycho Cut',
'Shockspray',
'Gluttony',
'Electroweb',
'Drain Punch',
'Shade Slash',
'Escaton',
'Acidic Slash',
'Frenzy',
'Icicle Crash',
'Flint Chip',
'X-Scissor',
'Demoltn Dash',
'Dragonhammer',
'Stygpowder',
'Blade Shot',
'Ice Shard'
} 

ability = {
'Overgrow','Overgrow',
'Overgrow','Overgrow',
'Overgrow','Overgrow',
'Blaze','Hustle',
'Blaze','Hustle',
'Blaze','Hustle',
'Torrent','Torrent',
'Torrent','Torrent',
'Torrent','Torrent',
'Shield Dust','Compoundeyes',
'Shield Dust','Compoundeyes',
'Shield Dust','Compoundeyes',
'Limber','Run Away',
'Static','Speed Boost',
'Static','Speed Boost',
'Run Away','Limber',
'Inner Focus','Pickup',
'Inner Focus','Keen Eye',
'Water Absorb','Water Veil',
'Run Away','Guts',
'Inner Focus','Keen Eye',
'Inner Focus','Keen Eye',
'Thick Fat','Own Tempo',
'Inner Focus','Keen Eye',
'Static','Static',
'Static','Static',
'Arena Trap','Arena Trap',
'Arena Trap','Arena Trap',
'Natural Cure','Chlorophyll',
'Poison Point','Poison Point',
'Poison Point','Poison Point',
'Natural Cure','Chlorophyll',
'Battle Armor','Rough Skin',
'Battle Armor','Rock Head',
'Cute Charm','Cute Charm',
'Cute Charm','Cute Charm',
'White Smoke','Battle Armor',
'White Smoke','Battle Armor',
'Cute Charm','Cute Charm',
'Cute Charm','Cute Charm',
'Pressure','Immunity',
'Pressure','Immunity',
'Drought','Drought',
'Drought','Drought',
'Own Tempo','Hustle',
'Own Tempo','Hustle',
'Own Tempo','Hustle',
'Compoundeyes','Compoundeyes',
'Shield Dust','Shield Dust',
'Sand Veil','Limber',
'Rock Head','Run Away',
'Pickup','Pickup',
'Limber','Limber',
'Damp','Cloud Nine',
'Damp','Cloud Nine',
'Huge Power','Huge Power',
'Huge Power','Huge Power',
'Pressure','Pressure',
'Pressure','Pressure',
'Run Away','Stench',
'Run Away','Stench',
'Run Away','Rain Dish',
'Natural Cure','Chlorophyll',
'Natural Cure','Chlorophyll',
'Synchronize','Inner Focus',
'Vital Spirit','Soundproof',
'Water Absorb','Water Veil',
'Water Absorb','Liquid Ooze',
'Chlorophyll','Chlorophyll',
'Chlorophyll','Chlorophyll',
'Chlorophyll','Chlorophyll',
'Clear Body','Liquid Ooze',
'Clear Body','Liquid Ooze',
'Soundproof','Soundproof',
'Soundproof','Soundproof',
'Soundproof','Soundproof',
'Pressure','Pressure',
'Pressure','Pressure',
'Volt Absorb','Lightningrod',
'Shadow Tag','Rough Skin',
'Volt Absorb','Lightningrod',
'Shadow Tag','Rough Skin',
'Lightningrod','Lightningrod',
'Lightningrod','Lightningrod',
'Lightningrod','Lightningrod',
'Thick Fat','Thick Fat',
'Thick Fat','Thick Fat',
'Stench','Sticky Hold',
'Stench','Sticky Hold',
'Shell Armor','Shell Armor',
'Shell Armor','Shell Armor',
'Shed Skin','Shield Dust',
'Hustle','Shield Dust',
'Shed Skin','Shield Dust',
'Battle Armor','Rock Head',
'Insomnia','Insomnia',
'Sand Veil','Shell Armor',
'Sand Veil','Shell Armor',
'Sand Veil','Shell Armor',
'Soundproof','Static',
'Soundproof','Static',
'Chlorophyll','Chlorophyll',
'Chlorophyll','Chlorophyll',
'Shield Dust','Battle Armor',
'Shield Dust','Battle Armor',
'Limber','Limber',
'Keen Eye','Keen Eye',
'Own Tempo','Oblivious',
'Levitate','Levitate',
'Levitate','Levitate',
'Rock Head','Sturdy',
'Rock Head','Sturdy',
'Natural Cure','Serene Grace',
'Chlorophyll','Chlorophyll',
'Battle Armor','Rock Head',
'Clear Body','Hustle',
'Poison Point','Poison Point',
'Flame Body','Magma Armor',
'Flame Body','Magma Armor',
'Illuminate','Natural Cure',
'Illuminate','Natural Cure',
'Soundproof','Soundproof',
'Swarm','Swarm',
'Oblivious','Oblivious',
'Static','Static',
'Flame Body','Flame Body',
'Stench','Compoundeyes',
'Intimidate','Intimidate',
'Swift Swim','Torrent',
'Flame Body','Magma Armor',
'Water Absorb','Shell Armor',
'Limber','Limber',
'Hyper Cutter','Hyper Cutter',
'Hyper Cutter','Hyper Cutter',
'Hyper Cutter','Hyper Cutter',
'Clear Body','Clear Body',
'Trace','Trace',
'Swift Swim','Torrent',
'Swift Swim','Torrent',
'Drizzle','Drizzle',
'Drizzle','Drizzle',
'Rock Head','Pressure',
'Immunity','Thick Fat',
'Pressure','Pressure',
'Pressure','Pressure',
'Pressure','Pressure',
'Hyper Cutter','Hyper Cutter',
'Hyper Cutter','Hyper Cutter',
'Hyper Cutter','Hyper Cutter',
'Pressure','Pressure',
'Synchronize','Synchronize',
'Overgrow','Overgrow',
'Serene Grace','Natural Cure',
'Serene Grace','Natural Cure',
'Blaze','Blaze',
'Hustle','Vital Spirit',
'Hustle','Vital Spirit',
'Lightningrod','Water Veil',
'Lightningrod','Water Veil',
'Lightningrod','Water Veil',
'Run Away','Keen Eye',
'Run Away','Keen Eye',
'Early Bird','Pressure',
'Early Bird','Pressure',
'Swarm','Early Bird',
'Swarm','Early Bird',
'Poison Point','Swarm',
'Poison Point','Swarm',
'Static','Swarm',
'Volt Absorb','Illuminate',
'Lightningrod','Water Veil',
'Static','Static',
'Cute Charm','Cute Charm',
'Cute Charm','Cute Charm',
'Hustle','Serene Grace',
'Hustle','Serene Grace',
'Trace','Synchronize',
'Trace','Synchronize',
'Static','Static',
'Static','Static',
'Static','Static',
'Chlorophyll','Chlorophyll',
'Thick Fat','Huge Power',
'Thick Fat','Huge Power',
'Sturdy','Rock Head',
'Water Absorb','Damp',
'Chlorophyll','Chlorophyll',
'Chlorophyll','Chlorophyll',
'Chlorophyll','Chlorophyll',
'Run Away','Pickup',
'Chlorophyll','Chlorophyll',
'Chlorophyll','Chlorophyll',
'Volt Absorb','Vital Spirit',
'Vital Spirit','Static',
'Vital Spirit','Static',
'Synchronize','Synchronize',
'Vital Spirit','Own Tempo',
'Trace','Synchronize',
'Oblivious','Own Tempo',
'Levitate','Levitate',
'Levitate','Levitate',
'Shadow Tag','Shadow Tag',
'Inner Focus','Early Bird',
'Lightningrod','Drizzle',
'Lightningrod','Drizzle',
'Pickup','Pickup',
'Blaze','Immunity',
'Blaze','Serene Grace',
'Blaze','Serene Grace',
'Blaze','Serene Grace',
'Blaze','Immunity',
'Volt Absorb','Vital Spirit',
'Sturdy','Sturdy',
'Swarm','Guts',
'Shadow Tag','Shadow Tag',
'Shadow Tag','Shadow Tag',
'Marvel Scale','Battle Armor',
'Flame Body','Magma Armor',
'Flame Body','Magma Armor',
'Oblivious','Oblivious',
'Oblivious','Oblivious',
'Hustle','Natural Cure',
'Levitate','Levitate',
'Shed Skin','Suction Cups',
'Vital Spirit','Hustle',
'Swift Swim','Water Absorb',
'Keen Eye','Sturdy',
'Guts','Guts',
'Guts','Guts',
'Guts','Guts',
'Thick Fat','Thick Fat',
'Thick Fat','Thick Fat',
'Trace','Trace',
'Intimidate','Intimidate',
'Own Tempo','Own Tempo',
'Guts','Guts',
'Intimidate','Intimidate',
'Oblivious','Oblivious',
'Static','Static',
'Flame Body','Flame Body',
'Thick Fat','Thick Fat',
'Natural Cure','Serene Grace',
'Pressure','Pressure',
'Pressure','Pressure',
'Pressure','Pressure',
'Blaze','Flash Fire',
'Rock Head','Shell Armor',
'Rock Head','Shell Armor',
'Blaze','Flash Fire',
'Pressure','Pressure',
'Natural Cure','Natural Cure',
'','',
'','',
'','',
'','',
'','',
'','',
'','',
'','',
'','',
'','',
'','',
'','',
'','',
'','',
'','',
'','',
'','',
'','',
'','',
'','',
'','',
'','',
'','',
'','',
'','',
'Effect Spore','Effect Spore',
'Effect Spore','Effect Spore',
'Effect Spore','Effect Spore',
'Marvel Scale','Rain Dish',
'Marvel Scale','Rain Dish',
'Marvel Scale','Rain Dish',
'Torrent','Torrent',
'Torrent','Torrent',
'Torrent','Torrent',
'Inner Focus','Pickup',
'Vital Spirit','Pickup',
'Pickup','Pickup',
'Serene Grace','Pickup',
'Compoundeyes','Rock Head',
'Compoundeyes','Rock Head',
'Compoundeyes','Rock Head',
'Compoundeyes','Rock Head',
'Arena Trap','Thick Fat',
'Swift Swim','Rain Dish',
'Swift Swim','Rain Dish',
'Swift Swim','Rain Dish',
'Chlorophyll','Early Bird',
'Chlorophyll','Early Bird',
'Chlorophyll','Early Bird',
'Compoundeyes','Compoundeyes',
'Speed Boost','Speed Boost',
'Wonder Guard','Wonder Guard',
'Guts','Guts',
'Guts','Guts',
'Hustle','Hustle',
'Hustle','Hustle',
'Own Tempo','Own Tempo',
'Vital Spirit','Pressure',
'Intimidate','Pressure',
'Shell Armor','Sturdy',
'Intimidate','Intimidate',
'Flash Fire','Own Tempo',
'Water Veil','Oblivious',
'Cute Charm','Cute Charm',
'Cute Charm','Cute Charm',
'Color Change','Color Change',
'Levitate','Levitate',
'Levitate','Levitate',
'Sturdy','Magnet Pull',
'White Smoke','White Smoke',
'Keen Eye','Keen Eye',
'Water Absorb','Swift Swim',
'Oblivious','Oblivious',
'Swift Swim','Swift Swim',
'Hyper Cutter','Immunity',
'Hyper Cutter','Shell Armor',
'Hyper Cutter','Shell Armor',
'Marvel Scale','Marvel Scale',
'Rough Skin','Rough Skin',
'Rough Skin','Rough Skin',
'Huge Power','Sand Veil',
'Huge Power','Sand Veil',
'Huge Power','Sand Veil',
'Thick Fat','Guts',
'Thick Fat','Guts',
'Static','Lightningrod',
'Poison Point','Lightningrod',
'Oblivious','Oblivious',
'Magma Armor','Magma Armor',
'Thick Fat','Thick Fat',
'Intimidate','Intimidate',
'Intimidate','Intimidate',
'Sand Veil','Sand Veil',
'Sand Veil','Sand Veil',
'Oblivious','Run Away',
'Inner Focus','Inner Focus',
'Oblivious','Run Away',
'Blaze','Blaze',
'Thick Fat','Huge Power',
'Thick Fat','Own Tempo',
'Thick Fat','Own Tempo',
'Plus','Plus',
'Minus','Minus',
'Hyper Cutter','Intimidate',
'Pure Power','Pure Power',
'Pure Power','Pure Power',
'Liquid Ooze','Limber',
'Run Away','Limber',
'Shadow Tag','Shadow Tag',
'Clear Body','Hustle',
'Clear Body','Volt Absorb',
'Natural Cure','Poison Point',
'Truant','Truant',
'Truant','Truant',
'Truant','Truant',
'Volt Absorb','Sticky Hold',
'Volt Absorb','Sticky Hold',
'Volt Absorb','Sticky Hold',
'Soundproof','Soundproof',
'Soundproof','Soundproof',
'Soundproof','Soundproof',
'Inner Focus','Cloud Nine',
'Inner Focus','Cloud Nine',
'Inner Focus','Cloud Nine',
'Sand Stream','Sand Stream',
'Rough Skin','Keen Eye',
'Rough Skin','Keen Eye',
'Shed Skin','Shed Skin',
'Immunity','Immunity',
'Rough Skin','Poison Point',
'Vital Spirit','Soundproof',
'Vital Spirit','Soundproof',
'Speed Boost','Speed Boost',
'Forecast','Forecast',
'Illuminate','Swarm',
'Oblivious','Oblivious',
'Battle Armor','Battle Armor',
'Battle Armor','Battle Armor',
'Natural Cure','Own Tempo',
'Thick Fat','Own Tempo',
'Cute Charm','Pickup',
'Synchronize','Trace',
'Synchronize','Trace',
'Intimidate','Intimidate',
'Rock Head','Rock Head',
'Battle Armor','Battle Armor',
'Clear Body','Clear Body',
'Clear Body','Clear Body',
'Clear Body','Clear Body',
'Intimidate','Intimidate',
'Pressure','Pressure',
'Intimidate','Intimidate',
'Drought','Drought',
'Rough Skin','Rough Skin',
'Air Lock','Air Lock',
'Levitate','Levitate',
'Levitate','Levitate',
'Serene Grace','Serene Grace',
'Pressure','Pressure',
'Levitate','Levitate',
}
-- Species growth curve table (0=Med Fast, 1=Erratic, 2=Fluctuating, 3=Med Slow, 4=Fast, 5=Slow)
-- Copied from Colors Script to properly resolve levels from EXP for boxed mons
curve = {
3,3,3,3,3,3,3,3,3,0, 0,0,0,0,0,3,3,3,0,0, 0,0,0,0,0,0,0,0,3,3, 3,3,3,3,4,4,0,0,4,4, 0,0,3,3,3,0,0,0,0,0,
0,0,0,0,0,0,0,5,5,3, 3,3,3,3,3,3,3,3,3,3, 3,5,5,3,3,3,0,0,0,0, 0,0,0,0,0,0,0,0,0,5, 5,3,3,3,0,0,0,0,0,0,
0,5,5,0,0,0,0,0,0,0, 5,5,4,0,0,0,0,0,0,5, 5,0,0,0,0,0,5,5,5,5, 5,0,0,0,0,0,0,0,0,0, 0,5,5,5,5,5,5,5,5,5,
3,3,3,3,3,3,3,3,3,3, 0,0,0,0,4,4,4,4,0,5, 5,0,4,4,4,4,0,0,3,3, 3,3,4,4,0,3,3,3,3,4, 3,3,0,0,0,0,0,3,0,4,
0,0,0,0,0,0,3,0,4,4, 0,0,3,5,3,0,0,0,0,5, 5,4,0,0,4,5,5,5,5,0, 0,0,0,5,4,0,0,0,0,0, 5,4,5,5,5,5,5,5,5,5,
3,2,2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,2,2, 2,2,2,2,2,2,3,3,3,3, 3,3,3,3,3,0,0,0,0,0, 0,0,0,0,3,3,3,3,3,3,
1,1,1,3,3,2,2,4,0,0, 0,0,2,2,4,4,3,0,0,0, 0,3,0,0,4,2,2,1,1,5, 5,3,3,3,2,2,5,5,0,0, 3,3,3,3,3,0,0,4,4,4,
4,4,0,0,4,0,0,1,1,0, 4,4,3,5,5,5,2,2,5,3, 3,3,1,1,1,3,4,4,2,1, 5,5,5,5,0,1,2,1,1,1, 1,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5, 4}
local substructSelector = {
	[ 0] = {0, 1, 2, 3},
	[ 1] = {0, 1, 3, 2},
	[ 2] = {0, 2, 1, 3},
	[ 3] = {0, 3, 1, 2},
	[ 4] = {0, 2, 3, 1},
	[ 5] = {0, 3, 2, 1},
	[ 6] = {1, 0, 2, 3},
	[ 7] = {1, 0, 3, 2},
	[ 8] = {2, 0, 1, 3},
	[ 9] = {3, 0, 1, 2},
	[10] = {2, 0, 3, 1},
	[11] = {3, 0, 2, 1},
	[12] = {1, 2, 0, 3},
	[13] = {1, 3, 0, 2},
	[14] = {2, 1, 0, 3},
	[15] = {3, 1, 0, 2},
	[16] = {2, 3, 0, 1},
	[17] = {3, 2, 0, 1},
	[18] = {1, 2, 3, 0},
	[19] = {1, 3, 2, 0},
	[20] = {2, 1, 3, 0},
	[21] = {3, 1, 2, 0},
	[22] = {2, 3, 1, 0},
	[23] = {3, 2, 1, 0},
}

local function BitXOR(a,b)--Bitwise xor
    local p,c=1,0
    while a>0 and b>0 do
        local ra,rb=a%2,b%2
        if ra~=rb then c=c+p end
        a,b,p=(a-ra)/2,(b-rb)/2,p*2
    end
    if a<b then a=b end
    while a>0 do
        local ra=a%2
        if ra>0 then c=c+p end
        a,p=(a-ra)/2,p*2
    end
    return c
end

local Game = {
	new = function (self, game)
		self.__index = self
		setmetatable(game, self)
		return game
	end
}

function firstCase(str)
	return firstToUpper(string.lower(str))
end

function firstToUpper(str)
    return (str:gsub("^%l", string.upper))
end


function Game.getParty(game)
	local party = {}
	local monStart = game._party
	local nameStart = game._partyNames
	local otStart = game._partyOt
	for i = 1, emu:read8(game._partyCount) do
		party[i] = game:_readPartyMon(monStart, nameStart, otStart)
		monStart = monStart + game._partyMonSize
		if game._partyNames then
			nameStart = nameStart + game._monNameLength + 1
		end
		if game._partyOt then
			otStart = otStart + game._playerNameLength + 1
		end
	end
	return party
end

function Game.toString(game, rawstring)
    local string = ""
    for _, char in ipairs({rawstring:byte(1, #rawstring)}) do
        if char == game._terminator then
            break
        end
        string = string..game._charmap[char]
    end
    -- Normalize special symbols used by the ROM into plain ASCII for exports
    -- Replace middle dot and multiplication sign with asterisk for names like "thundrbug*"
    string = string:gsub("・", "*")
                   :gsub("×", "*")
    return string
end

function Game.getSpeciesName(game, id)
	if game._speciesIndex then
		local index = game._index
		if not index then
			index = {}
			for i = 0, 255 do
				index[emu.memory.cart0:read8(game._speciesIndex + i)] = i
			end
			game._index = index
		end
		id = index[id]
	end
	if id==29 then
		return "Nidoran-F"
	elseif id==32 then
		return "Nidoran-M"
	else
	local pointer = game._speciesNameTable + (game._speciesNameLength) * id
	return game:toString(emu.memory.cart0:readRange(pointer, game._monNameLength))
	end
end

local GBGameEn = Game:new{
	_terminator=0x50,
	_monNameLength=10,
	_speciesNameLength=10,
	_playerNameLength=10,
}

local GBAGameEn = Game:new{
	_terminator=0xFF,
	_monNameLength=10,
	_speciesNameLength=11,
	_playerNameLength=10,
}

local Generation1En = GBGameEn:new{
	_boxMonSize=33,
	_partyMonSize=44,
	_readBoxMon=readBoxMonGen1,
	_readPartyMon=readPartyMonGen1,
}

local Generation2En = GBGameEn:new{
	_boxMonSize=32,
	_partyMonSize=48,
	_readBoxMon=readBoxMonGen2,
	_readPartyMon=readPartyMonGen2,
}

local Generation3En = GBAGameEn:new{
	_boxMonSize=80,
	_partyMonSize=100,
	_readBoxMon=readBoxMonGen3,
	_readPartyMon=readPartyMonGen3,
}

GBGameEn._charmap = { [0]=
	"�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�",
	"�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�",
	"�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�",
	"�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�",
	"�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�",
	"", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�",
	"�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�",
	"�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", " ",
	"A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P",
	"Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "(", ")", ":", ";", "[", "]",
	"a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p",
	"q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "é", "ʼd", "ʼl", "ʼs", "ʼt", "ʼv",
	"�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�",
	"�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�", "�",
	"'", "P\u{200d}k", "M\u{200d}n", "-", "ʼr", "ʼm", "?", "!", ".", "ァ", "ゥ", "ェ", "▹", "▸", "▾", "♂",
	"$", "×", ".", "/", ",", "♀", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"
}

GBAGameEn._charmap = { [0]=
	" ", "À", "Á", "Â", "Ç", "È", "É", "Ê", "Ë", "Ì", "こ", "Î", "Ï", "Ò", "Ó", "Ô",
	"Œ", "Ù", "Ú", "Û", "Ñ", "ß", "à", "á", "ね", "ç", "è", "é", "ê", "ë", "ì", "ま",
	"î", "ï", "ò", "ó", "ô", "œ", "ù", "ú", "û", "ñ", "º", "ª", "�", "&", "+", "あ",
	"ぃ", "ぅ", "ぇ", "ぉ", "v", "=", "ょ", "が", "ぎ", "ぐ", "げ", "ご", "ざ", "じ", "ず", "ぜ",
	"ぞ", "だ", "ぢ", "づ", "で", "ど", "ば", "び", "ぶ", "べ", "ぼ", "ぱ", "ぴ", "ぷ", "ぺ", "ぽ",
	"っ", "¿", "¡", "P\u{200d}k", "M\u{200d}n", "P\u{200d}o", "K\u{200d}é", "�", "�", "�", "Í", "%", "(", ")", "セ", "ソ",
	"タ", "チ", "ツ", "テ", "ト", "ナ", "ニ", "ヌ", "â", "ノ", "ハ", "ヒ", "フ", "ヘ", "ホ", "í",
	"ミ", "ム", "メ", "モ", "ヤ", "ユ", "ヨ", "ラ", "リ", "⬆", "⬇", "⬅", "➡", "ヲ", "ン", "ァ",
	"ィ", "ゥ", "ェ", "ォ", "ャ", "ュ", "ョ", "ガ", "ギ", "グ", "ゲ", "ゴ", "ザ", "ジ", "ズ", "ゼ",
	"ゾ", "ダ", "ヂ", "ヅ", "デ", "ド", "バ", "ビ", "ブ", "ベ", "ボ", "パ", "ピ", "プ", "ペ", "ポ",
	"ッ", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "!", "?", ".", "-", "・",
	"…", "“", "”", "‘", "’", "♂", "♀", "$", ",", "×", "/", "A", "B", "C", "D", "E",
	"F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U",
	"V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k",
	"l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "▶",
	":", "Ä", "Ö", "Ü", "ä", "ö", "ü", "⬆", "⬇", "⬅", "�", "�", "�", "�", "�", ""
}

function _read16BE(emu, address)
	return (emu:read8(address) << 8) | emu:read8(address + 1)
end

function Generation1En._readBoxMon(game, address, nameAddress, otAddress)
	local mon = {}
	mon.species = emu.memory.cart0:read8(game._speciesIndex + emu:read8(address + 0) - 1)
	mon.hp = _read16BE(emu, address + 1)
	mon.level = emu:read8(address + 3)
	mon.status = emu:read8(address + 4)
	mon.type1 = emu:read8(address + 5)
	mon.type2 = emu:read8(address + 6)
	mon.catchRate = emu:read8(address + 7)
	mon.moves = {
		emu:read8(address + 8),
		emu:read8(address + 9),
		emu:read8(address + 10),
		emu:read8(address + 11),
	}
	mon.otId = _read16BE(emu, address + 12)
	mon.experience = (_read16BE(emu, address + 14) << 8)| emu:read8(address + 16)
	mon.hpEV = _read16BE(emu, address + 17)
	mon.attackEV = _read16BE(emu, address + 19)
	mon.defenseEV = _read16BE(emu, address + 21)
	mon.speedEV = _read16BE(emu, address + 23)
	mon.spAttackEV = _read16BE(emu, address + 25)
	mon.spDefenseEV = mon.spAttackEv
	local iv = _read16BE(emu, address + 27)
	mon.attackIV = (iv >> 4) & 0xF
	mon.defenseIV = iv & 0xF
	mon.speedIV = (iv >> 12) & 0xF
	mon.spAttackIV = (iv >> 8) & 0xF
	mon.spDefenseIV = mon.spAttackIV
	mon.pp = {
		emu:read8(address + 28),
		emu:read8(address + 29),
		emu:read8(address + 30),
		emu:read8(address + 31),
	}
	mon.nickname = game:toString(emu:readRange(nameAddress, game._monNameLength))
	mon.otName = game:toString(emu:readRange(otAddress, game._playerNameLength))
	return mon
end

function Generation1En._readPartyMon(game, address, nameAddress, otAddress)
	local mon = game:_readBoxMon(address, nameAddress, otAddress)
	mon.level = emu:read8(address + 33)
	mon.maxHP = _read16BE(emu, address + 34)
	mon.attack = _read16BE(emu, address + 36)
	mon.defense = _read16BE(emu, address + 38)
	mon.speed = _read16BE(emu, address + 40)
	mon.spAttack = _read16BE(emu, address + 42)
	mon.spDefense = mon.spAttack
	return mon
end

function  Generation2En._readBoxMon(game, address, nameAddress, otAddress)
	local mon = {}
	mon.species = emu:read8(address + 0)
	mon.item = emu:read8(address + 1)
	mon.moves = {
		emu:read8(address + 2),
		emu:read8(address + 3),
		emu:read8(address + 4),
		emu:read8(address + 5),
	}
	mon.otId = _read16BE(emu, address + 6)
	mon.experience = (_read16BE(emu, address + 8) << 8)| emu:read8(address + 10)
	mon.hpEV = _read16BE(emu, address + 11)
	mon.attackEV = _read16BE(emu, address + 13)
	mon.defenseEV = _read16BE(emu, address + 15)
	mon.speedEV = _read16BE(emu, address + 17)
	mon.spAttackEV = _read16BE(emu, address + 19)
	mon.spDefenseEV = mon.spAttackEv
	local iv = _read16BE(emu, address + 21)
	mon.attackIV = (iv >> 4) & 0xF
	mon.defenseIV = iv & 0xF
	mon.speedIV = (iv >> 12) & 0xF
	mon.spAttackIV = (iv >> 8) & 0xF
	mon.spDefenseIV = mon.spAttackIV
	mon.pp = {
		emu:read8(address + 23),
		emu:read8(address + 24),
		emu:read8(address + 25),
		emu:read8(address + 26),
	}
	mon.friendship = emu:read8(address + 27)
	mon.pokerus = emu:read8(address + 28)
	local caughtData = _read16BE(emu, address + 29)
	mon.metLocation = (caughtData >> 8) & 0x7F
	mon.metLevel = caughtData & 0x1F
	mon.level = emu:read8(address + 31)
	mon.nickname = game:toString(emu:readRange(nameAddress, game._monNameLength))
	mon.otName = game:toString(emu:readRange(otAddress, game._playerNameLength))
	return mon
end

function Generation2En._readPartyMon(game, address, nameAddress, otAddress)
	local mon = game:_readBoxMon(address, nameAddress, otAddress)
	mon.status = emu:read8(address + 32)
	mon.hp = _read16BE(emu, address + 34)
	mon.maxHP = _read16BE(emu, address + 36)
	mon.attack = _read16BE(emu, address + 38)
	mon.defense = _read16BE(emu, address + 40)
	mon.speed = _read16BE(emu, address + 42)
	mon.spAttack = _read16BE(emu, address + 44)
	mon.spDefense = _read16BE(emu, address + 46)
	return mon
end

function Generation3En._readBoxMon(game, address)
	local mon = {}
	mon.personality = emu:read32(address + 0)
	mon.otId = emu:read32(address + 4)
	mon.nickname = game:toString(emu:readRange(address + 8, game._monNameLength))
	mon.language = emu:read8(address + 18)
	local flags = emu:read8(address + 19)
	mon.isBadEgg = flags & 1
	mon.hasSpecies = (flags >> 1) & 1
	mon.isEgg = (flags >> 2) & 1
	mon.otName = game:toString(emu:readRange(address + 20, game._playerNameLength))
	mon.markings = emu:read8(address + 27)
	mon.checksum = emu:read16(address + 28)

	local key = mon.otId ~ mon.personality

	local pSel = substructSelector[mon.personality % 24]
	local ss0 = {}
	local ss1 = {}
	local ss2 = {}
	local ss3 = {}

	for i = 0, 2 do
		ss0[i] = emu:read32(address + 32 + pSel[1] * 12 + i * 4) ~ key
		ss1[i] = emu:read32(address + 32 + pSel[2] * 12 + i * 4) ~ key
		ss2[i] = emu:read32(address + 32 + pSel[3] * 12 + i * 4) ~ key
		ss3[i] = emu:read32(address + 32 + pSel[4] * 12 + i * 4) ~ key
	end
	mon.species = ss0[0] & 0xFFFF
	mon.heldItem = ss0[0] >> 16
	mon.experience = ss0[1]
	mon.ppBonuses = ss0[2] & 0xFF
	mon.friendship = (ss0[2] >> 8) & 0xFF

	mon.moves = {
		ss1[0] & 0xFFFF,
		ss1[0] >> 16,
		ss1[1] & 0xFFFF,
		ss1[1] >> 16
	}
	mon.pp = {
		ss1[2] & 0xFF,
		(ss1[2] >> 8) & 0xFF,
		(ss1[2] >> 16) & 0xFF,
		ss1[2] >> 24
	}

	mon.hpEV = ss2[0] & 0xFF
	mon.attackEV = (ss2[0] >> 8) & 0xFF
	mon.defenseEV = (ss2[0] >> 16) & 0xFF
	mon.speedEV = ss2[0] >> 24
	mon.spAttackEV = ss2[1] & 0xFF
	mon.spDefenseEV = (ss2[1] >> 8) & 0xFF
	mon.cool = (ss2[1] >> 16) & 0xFF
	mon.beauty = ss2[1] >> 24
	mon.cute = ss2[2] & 0xFF
	mon.smart = (ss2[2] >> 8) & 0xFF
	mon.tough = (ss2[2] >> 16) & 0xFF
	mon.sheen = ss2[2] >> 24

	mon.pokerus = ss3[0] & 0xFF
	mon.metLocation = (ss3[0] >> 8) & 0xFF
	flags = ss3[0] >> 16
	mon.metLevel = flags & 0x7F
	mon.metGame = (flags >> 7) & 0xF
	mon.pokeball = (flags >> 11) & 0xF
	mon.otGender = (flags >> 15) & 0x1
	flags = ss3[1]
	mon.hpIV = flags & 0x1F
	mon.attackIV = (flags >> 5) & 0x1F
	mon.defenseIV = (flags >> 10) & 0x1F
	mon.speedIV = (flags >> 15) & 0x1F
	mon.spAttackIV = (flags >> 20) & 0x1F
	mon.spDefenseIV = (flags >> 25) & 0x1F
	-- Bit 30 is another "isEgg" bit
	mon.altAbility = (flags >> 31) & 1
	flags = ss3[2]
	mon.coolRibbon = flags & 7
	mon.beautyRibbon = (flags >> 3) & 7
	mon.cuteRibbon = (flags >> 6) & 7
	mon.smartRibbon = (flags >> 9) & 7
	mon.toughRibbon = (flags >> 12) & 7
	mon.championRibbon = (flags >> 15) & 1
	mon.winningRibbon = (flags >> 16) & 1
	mon.victoryRibbon = (flags >> 17) & 1
	mon.artistRibbon = (flags >> 18) & 1
	mon.effortRibbon = (flags >> 19) & 1
	mon.marineRibbon = (flags >> 20) & 1
	mon.landRibbon = (flags >> 21) & 1
	mon.skyRibbon = (flags >> 22) & 1
	mon.countryRibbon = (flags >> 23) & 1
	mon.nationalRibbon = (flags >> 24) & 1
	mon.earthRibbon = (flags >> 25) & 1
	mon.worldRibbon = (flags >> 26) & 1
	mon.eventLegal = (flags >> 27) & 0x1F
	return mon
end

function Generation3En._readPartyMon(game, address)
	local mon = game:_readBoxMon(address)
	mon.status = emu:read32(address + 80)
	mon.level = emu:read8(address + 84)
	mon.mail = emu:read32(address + 85)
	mon.hp = emu:read16(address + 86)
	mon.maxHP = emu:read16(address + 88)
	mon.attack = emu:read16(address + 90)
	mon.defense = emu:read16(address + 92)
	mon.speed = emu:read16(address + 94)
	mon.spAttack = emu:read16(address + 96)
	mon.spDefense = emu:read16(address + 98)
	return mon
end

local gameRBEn = Generation1En:new{
	name="Red/Blue (USA)",
	_party=0xd16b,
	_partyCount=0xd163,
	_partyNames=0xd2b5,
	_partyOt=0xd273,
	_speciesNameTable=0x1c21e,
	_speciesIndex=0x41024,
}

local gameYellowEn = Generation1En:new{
	name="Yellow (USA)",
	_party=0xd16a,
	_partyCount=0xd162,
	_partyNames=0xd2b4,
	_partyOt=0xd272,
	_speciesNameTable=0xe8000,
	_speciesIndex=0x410b1,
}

local gameGSEn = Generation2En:new{
	name="Gold/Silver (USA)",
	_party=0xda2a,
	_partyCount=0xda22,
	_partyNames=0xdb8c,
	_partyOt=0xdb4a,
	_speciesNameTable=0x1b0b6a,
}

local gameCrystalEn = Generation2En:new{
	name="Crystal (USA)",
	_party=0xdcdf,
	_partyCount=0xdcd7,
	_partyNames=0xde41,
	_partyOt=0xddff,
	_speciesNameTable=0x5337a,
}

local gameRubyEn = Generation3En:new{
	name="Ruby (USA)",
	_party=0x3004360,
	_partyCount=0x3004350,
	_speciesNameTable=0x1f716c,
}

local gameSapphireEn = Generation3En:new{
	name="Sapphire (USA)",
	_party=0x3004360,
	_partyCount=0x3004350,
	_speciesNameTable=0x1f70fc,
}

local gameEmeraldEn = Generation3En:new{
    name="Emerald (USA)",
    _party=0x20244ec,
    _partyCount=0x20244e9,
    _speciesNameTable=0x3185c8,
    -- gBattleMoves table (ROM/carto space offset), used to read base PP
    _moveDataTable=0xE8DB00,
    _moveDataStride=12,
    _moveDataBaseOffset=0x10,
    -- PP sits at byte 1 (0-based) in each 12-byte entry.
    _movePPOffset=1,
    -- Entries start at base+0x10; index 0 is move 1
    _moveDataIndexOffset=0,
}

local gameFireRedEn = Generation3En:new{
	name="FireRed (USA)",
	_party=0x2024284,
	_partyCount=0x2024029,
	_speciesNameTable=0x245ee0,
}

local gameFireRedEnR1 = gameFireRedEn:new{
	name="FireRed (USA) (Rev 1)",
	_speciesNameTable=0x245f50,
}

local gameLeafGreenEn = Generation3En:new{
	name="LeafGreen (USA)",
	_party=0x2024284,
	_partyCount=0x2024029,
	_speciesNameTable=0x245f2c,
}

local gameLeafGreenEnR1 = gameLeafGreenEn:new{
	name="LeafGreen (USA)",
	_party=0x2024284,
	_partyCount=0x2024029,
	_speciesNameTable=0x245f2c,
}

gameCodes = {
	["DMG-AAUE"]=gameGSEn, -- Gold
	["DMG-AAXE"]=gameGSEn, -- Silver
	["CGB-BYTE"]=gameCrystalEn,
	["AGB-AXVE"]=gameRubyEn,
	["AGB-AXPE"]=gameSapphireEn,
	["AGB-BPEE"]=gameEmeraldEn,
	["AGB-BPRE"]=gameFireRedEn,
	["AGB-BPGE"]=gameLeafGreenEn,
}

-- These versions have slight differences and/or cannot be uniquely
-- identified by their in-header game codes, so fall back on a CRC32
gameCrc32 = {
	[0x9f7fdd53] = gameRBEn, -- Red
	[0xd6da8a1a] = gameRBEn, -- Blue
	[0x7d527d62] = gameYellowEn,
	[0x3358e30a] = gameCrystal, -- Crystal rev 1
	[0x84ee4776] = gameFireRedEnR1,
	[0xdaffecec] = gameLeafGreenEnR1,
}

function printPartyStatus(game, buffer)
	buffer:clear()
	for _, mon in ipairs(game:getParty()) do
		buffer:print(string.format("%-10s (Lv%3i %10s): %3i/%3i\n",
			mon.nickname,
			resolvedLevel(mon),
			game:getSpeciesName(mon.species),
			mon.hp,
			mon.maxHP))
	end
end

function detectGame()
	local checksum = 0
	for i, v in ipairs({emu:checksum(C.CHECKSUM.CRC32):byte(1, 4)}) do
		checksum = checksum * 256 + v
	end
	game = gameCrc32[checksum]
	if not game then
		game = gameCodes[emu:getGameCode()]
	end

	if not game then
		console:error("Unknown game!")
	else
		console:log("Found game: " .. game.name)
	end
end

function statusSlot(slot, status)
    local pcount = emu:read8(game._partyCount)
    if slot <= pcount and slot >= 1 then
        local base = game._party
        local size = game._partyMonSize or 100 -- Gen 3 default
        emu:write32(base + 80 + size * (slot - 1), status)
    else
        console:log("Invalid Slot, slot out of range")
    end
end

function sleep(slot)
    statusSlot(slot, 1)
end

function poison(slot)
    statusSlot(slot, 8)
end

function burn(slot)
    statusSlot(slot, 16)
end

function freeze(slot)
    statusSlot(slot, 32)
end

function paralyze(slot)
    statusSlot(slot, 64)
end

function bedtime()
	for i=emu:read8(game._partyCount),1,-1 do
		statusSlot(i, 1)
	end
end

function sethp(slot, hp)
    local pcount = emu:read8(game._partyCount)
    if slot < 1 or slot > pcount then
        console:log("Invalid Slot, slot out of range")
        return
    end
    local base = game._party
    local size = game._partyMonSize or 100
    local maxAddr = base + 88 + size * (slot - 1)
    local curAddr = base + 86 + size * (slot - 1)
    local maxHP = emu:read16(maxAddr)
    if hp < 1 or hp > maxHP then
        console:log("Invalid HP")
        return
    end
    emu:write16(curAddr, hp)
end

-- Optional base PP table for Gen 1/2 moves. Populate entries as needed for exact caps.
-- Keys are move IDs (1-based, matching the in-game IDs used in party data for Gen1/2).
-- Example: moveBasePPGen12[1] = 35  -- Pound
local moveBasePPGen12 = moveBasePPGen12 or {}

-- Generic ROM-backed move PP reader. Configure per-game:
--   game._moveDataTable   -> ROM base of move data table (cart space, not 0x08000000 prefixed)
--   game._moveDataStride  -> bytes per move entry (defaults: Gen3=12)
--   game._movePPOffset    -> offset of PP byte within entry (defaults: 4 for Gen3)
local function _readBasePPFromROM(moveId)
    if not game or not game._moveDataTable then return nil end
    if not moveId or moveId < 1 then return nil end
    local stride = game._moveDataStride or 12
    local ppOff = game._movePPOffset
    if ppOff == nil then
        -- Sensible default per engine; Gen3 uses 4
        if game._partyMonSize == 100 then
            ppOff = 4
        else
            -- Gen1/2 commonly also place PP early in the struct
            ppOff = 4
        end
    end
    local indexOffset = game._moveDataIndexOffset or 0
    local baseOffset = game._moveDataBaseOffset or 0
    local entryIndex = (moveId - 1) + indexOffset
    local addr = game._moveDataTable + baseOffset + entryIndex * stride + ppOff
    local pp = emu.memory.cart0:read8(addr)
    local function isValidPP(x)
        if not x then return false end
        -- Typical Gen 3 PP values are multiples of 5 from 5..40
        return (x == 5 or x == 10 or x == 15 or x == 20 or x == 25 or x == 30 or x == 35 or x == 40)
    end
    if isValidPP(pp) then return pp end
    -- Fallback probing for hacks with different layouts;
    -- try a few common PP byte offsets within the entry.
    local candidates = {1, 4, 5, 7, 9, 13}
    for _, off in ipairs(candidates) do
        if off ~= ppOff then
            local v = emu.memory.cart0:read8(game._moveDataTable + baseOffset + entryIndex * stride + off)
            if isValidPP(v) then
                -- Do not globally cache; some hacks interleave fields inconsistently
                return v
            end
        end
    end

    -- Heuristic scan: look for an accuracy byte (1..100) followed by a valid PP byte.
    -- Use the last matching pair in the entry.
    local best
    for i = 0, stride - 2 do
        local acc = emu.memory.cart0:read8(game._moveDataTable + baseOffset + entryIndex * stride + i)
        local pv  = emu.memory.cart0:read8(game._moveDataTable + baseOffset + entryIndex * stride + i + 1)
        if acc and acc > 0 and acc <= 100 and isValidPP(pv) then
            best = pv
        end
    end
    if best then return best end
    return nil
end

-- Debug helper: Inspect raw move entry bytes and derived PP
function debugMoveEntry(moveId)
    if not game or not game._moveDataTable then
        console:log("No ROM move table configured for this game.")
        return
    end
    if not moveId or moveId < 1 then
        console:log("Provide a valid moveId (>=1)")
        return
    end
    local stride = game._moveDataStride or 12
    local indexOffset = game._moveDataIndexOffset or 0
    local baseOffset = game._moveDataBaseOffset or 0
    local base = game._moveDataTable + baseOffset + ((moveId - 1) + indexOffset) * stride
    local bytes = {}
    for i = 0, stride - 1 do
        bytes[#bytes + 1] = string.format("%02X", emu.memory.cart0:read8(base + i))
    end
    local pp = _readBasePPFromROM(moveId)
    console:log(string.format("Move %d @ 0x%06X: %s | stride=%d off=%d PP=%s",
        moveId, base, table.concat(bytes, " "), stride, game._movePPOffset or -1, tostring(pp)))
end

local function _getBasePP_gen1_2(moveId)
    if not moveId or moveId == 0 then return nil end
    -- Prefer ROM if configured, fallback to table
    return _readBasePPFromROM(moveId) or moveBasePPGen12[moveId]
end

local function _healpp_gen1_2()
    local pcount = emu:read8(game._partyCount)
    if not pcount or pcount < 1 then return end
    local base = game._party
    local size = game._partyMonSize or 48

    -- Determine layout-specific offsets
    local isGen1 = (size == 44)
    local movesOff = isGen1 and 8 or 2
    local ppOff    = isGen1 and 28 or 23

    for i = 1, pcount do
        local monBase = base + size * (i - 1)
        for j = 0, 3 do
            local moveId = emu:read8(monBase + movesOff + j)
            local ppByte = emu:read8(monBase + ppOff + j)
            if moveId and moveId > 0 and ppByte then
                local ups = (ppByte >> 6) & 0x3        -- top 2 bits store PP Ups used
                local current = ppByte & 0x3F          -- lower 6 bits is current PP
                local basePP = _getBasePP_gen1_2(moveId)
                if basePP and basePP > 0 then
                    local maxPP = _ppUps_to_max(basePP, ups)
                    if maxPP > 63 then maxPP = 63 end  -- storage cap in Gen1/2
                    local newByte = ((ups & 0x3) << 6) | (maxPP & 0x3F)
                    emu:write8(monBase + ppOff + j, newByte)
                else
                    -- Unknown base: leave as-is to avoid UI showing 63
                    emu:write8(monBase + ppOff + j, ppByte)
                end
            end
        end
    end
end

-- Optional base PP table for Gen 3 moves. Populate entries as needed for exact caps.
-- Keys are move IDs (1-based, matching the in-game IDs used in party data).
-- Example: moveBasePP[1] = 35  -- Pound
local moveBasePP = moveBasePP or {}

local function _ppUps_to_max(base, ups)
    -- ups is 0..3; max = floor(base * (5 + ups) / 5)
    return math.floor((base * (5 + ups)) / 5)
end

local function _getBasePP_gen3(moveId)
    if not moveId or moveId == 0 then return nil end
    -- Prefer ROM if configured, fallback to table
    return _readBasePPFromROM(moveId) or moveBasePP[moveId]
end

-- Gen 3 (MHE) PP heal: decrypt substructures, set each move's PP to its true max when known,
-- re-encrypt, and fix checksum. Falls back to leaving PP unchanged if base PP is unknown.
local function _healpp_gen3()
    local pcount = emu:read8(game._partyCount)
    if not pcount or pcount < 1 then return end
    local base = game._party
    local size = game._partyMonSize or 100
    for i = 1, pcount do
        local addr = base + size * (i - 1)
        local personality = emu:read32(addr + 0)
        local otId = emu:read32(addr + 4)
        local key = otId ~ personality
        local pSel = substructSelector[personality % 24]
        if not pSel then goto continue end

        -- Decrypt relevant substructures
        local ss0_off = addr + 32 + pSel[1] * 12
        local ss1_off = addr + 32 + pSel[2] * 12
        local ss0_0 = emu:read32(ss0_off + 0) ~ key
        local ss0_1 = emu:read32(ss0_off + 4) ~ key
        local ss0_2 = emu:read32(ss0_off + 8) ~ key
        local w0 = emu:read32(ss1_off + 0) ~ key
        local w1 = emu:read32(ss1_off + 4) ~ key
        local w2 = emu:read32(ss1_off + 8) ~ key

        -- Extract move IDs and PP bonuses (two bits per move, in ss0_2 low byte)
        local move1 = w0 & 0xFFFF
        local move2 = (w0 >> 16) & 0xFFFF
        local move3 = w1 & 0xFFFF
        local move4 = (w1 >> 16) & 0xFFFF
        local ppBonuses = ss0_2 & 0xFF

        -- Current PP bytes
        local pp1 = w2 & 0xFF
        local pp2 = (w2 >> 8) & 0xFF
        local pp3 = (w2 >> 16) & 0xFF
        local pp4 = (w2 >> 24) & 0xFF

        local function heal_slot(curPP, moveId, upsBits)
            local base = _getBasePP_gen3(moveId)
            if base and base > 0 then
                local maxPP = _ppUps_to_max(base, upsBits)
                return maxPP
            else
                -- Unknown base PP: leave as-is to avoid UI showing 63
                return curPP
            end
        end

        -- Decode PP Ups used per move (2 bits each)
        local u1 = ppBonuses & 0x3
        local u2 = (ppBonuses >> 2) & 0x3
        local u3 = (ppBonuses >> 4) & 0x3
        local u4 = (ppBonuses >> 6) & 0x3

        pp1 = heal_slot(pp1, move1, u1)
        pp2 = heal_slot(pp2, move2, u2)
        pp3 = heal_slot(pp3, move3, u3)
        pp4 = heal_slot(pp4, move4, u4)

        -- Recombine PP bytes
        w2 = (pp1 & 0xFF) | ((pp2 & 0xFF) << 8) | ((pp3 & 0xFF) << 16) | ((pp4 & 0xFF) << 24)
        -- Re-encrypt and write back
        emu:write32(ss1_off + 0, (w0 ~ key))
        emu:write32(ss1_off + 4, (w1 ~ key))
        emu:write32(ss1_off + 8, (w2 ~ key))

        -- Recalculate and write checksum (sum of 48 bytes of decrypted substructures as 16-bit words)
        local sum = 0
        for block = 1, 4 do
            local off = addr + 32 + pSel[block] * 12
            for j = 0, 2 do
                local dec = emu:read32(off + j * 4) ~ key
                sum = (sum + (dec & 0xFFFF) + ((dec >> 16) & 0xFFFF)) & 0xFFFF
            end
        end
        emu:write16(addr + 28, sum)

        ::continue::
    end
end

function healpp()
    -- Detect gen by party mon size heuristic; MHE (Gen 3) uses 100
    if game and (game._partyMonSize == 100) then
        _healpp_gen3()
    else
        _healpp_gen1_2()
    end
end

-- Fully heal the entire party: clear status, restore HP to max, and PP
function healparty()
    local pcount = emu:read8(game._partyCount)
    if not pcount or pcount < 1 then
        return
    end
    local base = game._party
    local size = game._partyMonSize or 100 -- Gen 3 default layout
    for i = 1, pcount do
        -- Clear status
        emu:write32(base + 80 + size * (i - 1), 0)
        -- Restore HP to max
        local curAddr = base + 86 + size * (i - 1)
        local maxAddr = base + 88 + size * (i - 1)
        local maxHP = emu:read16(maxAddr)
        if maxHP and maxHP > 0 then
            emu:write16(curAddr, maxHP)
        end
    end
    -- Restore PP for all moves
    healpp()
end

function getMove(curMove)
	curMove = move[curMove]
	if not curMove then
		curMove = ""
	end
	return curMove
end

-- Growth-rate curves (borrowed from Colors Script) and EXP->Level resolution
-- curve values: 0=Medium Fast, 1=Erratic, 2=Fluctuating, 3=Medium Slow, 4=Fast, 5=Slow
curve = {
3,3,3,3,3,3,3,3,3,0, 0,0,0,0,0,3,3,3,0,0, 0,0,0,0,0,0,0,0,3,3, 3,3,3,3,4,4,0,0,4,4, 0,0,3,3,3,0,0,0,0,0,
0,0,0,0,0,0,0,5,5,3, 3,3,3,3,3,3,3,3,3,3, 3,5,5,3,3,3,0,0,0,0, 0,0,0,0,0,0,0,0,0,5, 5,3,3,3,0,0,0,0,0,0,
0,5,5,0,0,0,0,0,0,0, 5,5,4,0,0,0,0,0,0,5, 5,0,0,0,0,0,5,5,5,5, 5,0,0,0,0,0,0,0,0,0, 0,5,5,5,5,5,5,5,5,5,
3,3,3,3,3,3,3,3,3,3, 0,0,0,0,4,4,4,4,0,5, 5,0,4,4,4,4,0,0,3,3, 3,3,4,4,0,3,3,3,3,4, 3,3,0,0,0,0,0,3,0,4,
0,0,0,0,0,0,3,0,4,4, 0,0,3,5,3,0,0,0,0,5, 5,4,0,0,4,5,5,5,5,0, 0,0,0,5,4,0,0,0,0,0, 5,4,5,5,5,5,5,5,5,5,
3,2,2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,2,2, 2,2,2,2,2,2,3,3,3,3, 3,3,3,3,3,0,0,0,0,0, 0,0,0,0,3,3,3,3,3,3,
1,1,1,3,3,2,2,4,0,0, 0,0,2,2,4,4,3,0,0,0, 0,3,0,0,4,2,2,1,1,5, 5,3,3,3,2,2,5,5,0,0, 3,3,3,3,3,0,0,4,4,4,
4,4,0,0,4,0,0,1,1,0, 4,4,3,5,5,5,2,2,5,3, 3,3,1,1,1,3,4,4,2,1, 5,5,5,5,0,1,2,1,1,1, 1,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5, 4}

local function slowCurve(n)        return math.floor((5*(n^3))/4) end
local function fastCurve(n)        return math.floor((4*(n^3))/5) end
local function medfastCurve(n)     return n^3 end
local function medslowCurve(n)     return math.floor((6*n^3)/5) - (15*n^2) + (100*n) - 140 end
local function erraticCurve(n)
    if n <= 50 then
        return math.floor(((100 - n)*n^3)/50)
    elseif n <= 68 then
        return math.floor(((150 - n)*n^3)/50)
    elseif n <= 98 then
        return math.floor(math.floor((1911 - 10*n)/3) * n^23 / 500)
    else
        return math.floor((160 - n) * n^3 / 100)
    end
end
local function flutuatingCurve(n)
    if n < 15 then
        return math.floor((math.floor((n + 1) / 3) + 24) * n^3 / 50)
    elseif n <= 36 then
        return math.floor((n + 14) * n^3 / 50)
    else
        return math.floor((math.floor(n / 2) + 32) * n^3 / 50)
    end
end

local function expRequired(species, level)
    local expCurve = curve and curve[species]
    if expCurve == 1 then return erraticCurve(level) end
    if expCurve == 2 then return flutuatingCurve(level) end
    if expCurve == 3 then return medslowCurve(level) end
    if expCurve == 4 then return fastCurve(level) end
    if expCurve == 5 then return slowCurve(level) end
    -- Default and for expCurve==0: Medium Fast
    return medfastCurve(level)
end

local function calcLevel(exp, species)
    exp = exp or 0
    if exp <= 0 then return 1 end
    local level = 1
    while level < 100 and exp >= expRequired(species, level + 1) do
        level = level + 1
    end
    return level
end

local function resolvedLevel(mon)
    if mon and mon.level and mon.level > 0 then return mon.level end
    if mon and mon.experience then
        local species = mon.species or 1
        return calcLevel(mon.experience, species)
    end
    return 1
end

-- Returns the level of the first Pokémon in the party (leader),
-- or nil if no party Pokémon exist. Falls back to EXP resolution
-- if a stored level is unavailable.
local function getLeadLevel()
    if not game or not game._partyCount then return nil end
    local pcount = emu:read8(game._partyCount)
    if not pcount or pcount < 1 then return nil end
    local party = game:getParty()
    if not party or not party[1] then return nil end
    local lead = party[1]
    if lead.level and lead.level > 0 then return lead.level end
    return resolvedLevel(lead)
end

local function abilityName(mon)
    local idx = (mon.species * 2) - 1 + (mon.altAbility or 0)
    local ab = ability[idx]
    if not ab then return "" end
    return ab
end

function printBoxMon(address)
    local mon = game:_readBoxMon(address)
    str = ""
    str = str .. mon.nickname .. " (" .. firstCase(game:getSpeciesName(mon.species) .. ")")
	if (item[mon.heldItem]) then
		str = str .. string.format(" @ %s", item[mon.heldItem])
	end
	str = str .. string.format("\n")
    str = str .. "Ability: " .. string.format("%s", abilityName(mon)) .. string.format("\n")
	-- For boxed mons, force level to match the party leader if present
	local leadLevel = getLeadLevel()
	str = str .. string.format("Level: %d\n", leadLevel or resolvedLevel(mon))
	str = str .. string.format("%s", nature[(mon.personality % 25)+1]) .. " Nature" .. string.format("\n")
	str = str .. string.format("IVs: %d HP / %d Atk / %d Def / %d SpA / %d SpD / %d Spe", mon.hpIV, mon.attackIV, mon.defenseIV, mon.spAttackIV, mon.spDefenseIV, mon.speedIV) .. string.format("\n")
	if(getMove(mon.moves[1]) ~= "") then
		str = str .. string.format("- %s\n", getMove(mon.moves[1]))
	end
	if(getMove(mon.moves[2]) ~= "") then
		str = str .. string.format("- %s\n", getMove(mon.moves[2]))
	end
	if(getMove(mon.moves[3]) ~= "") then
		str = str .. string.format("- %s\n", getMove(mon.moves[3]))
	end
	if(getMove(mon.moves[4]) ~= "") then
		str = str .. string.format("- %s\n", getMove(mon.moves[4]))
	end
	str = str .. string.format("\n")
	buffer:print(str)
end

function export()
    -- Export party, then ALL PC boxes (Gen 3 / Emerald engine)
    -- Prefer runtime pointer for ROM hacks; fallback to vanilla base.
    local storagePtr = emu:read32(0x03005D94)
    local storage
    if storagePtr >= 0x02000000 and storagePtr < 0x02040000 then
        storage = storagePtr
    else
        storage = 0x02029800 -- vanilla Emerald gPokemonStorage
    end

    local BOX_COUNT = 14
    local BOX_STRIDE = 0x96C -- includes per-box metadata after 30 mons
    local MON_SIZE = game._boxMonSize or 80
    local BOXES_BASE = storage + 0x04

    exportparty()
    for b = 0, BOX_COUNT - 1 do
        local boxBase = BOXES_BASE + (b * BOX_STRIDE)
        -- Removed box header printing per request
        for i = 0, 29 do
            local slot = boxBase + (i * MON_SIZE)
            if (emu:read32(slot) ~= 0) then
                local mon = game:_readBoxMon(slot)
                local hasSpecies = (mon.hasSpecies == 1) or (mon.species and mon.species > 0)
                local idxOK = (mon.species and ((mon.species * 2) <= #ability))
                if hasSpecies and idxOK then
                    printBoxMon(slot)
                end
            end
        end
    end
end

function exportparty()
	buffer:clear()
    for _, mon in ipairs(game:getParty()) do
		str = ""
		str = str .. mon.nickname .. " (" .. firstCase(game:getSpeciesName(mon.species) .. ")")
		if (item[mon.heldItem]) then
			str = str .. string.format(" @ %s", item[mon.heldItem])
		end
		str = str .. string.format("\n")
        str = str .. "Ability: " .. string.format("%s", abilityName(mon)) .. string.format("\n")
		-- Party mons have a stored level; still use resolver for safety
		str = str .. string.format("Level: %d\n", resolvedLevel(mon))
		str = str .. string.format("%s", nature[(mon.personality % 25)+1]) .. " Nature" .. string.format("\n")
		str = str .. string.format("IVs: %d HP / %d Atk / %d Def / %d SpA / %d SpD / %d Spe", mon.hpIV, mon.attackIV, mon.defenseIV, mon.spAttackIV, mon.spDefenseIV, mon.speedIV) .. string.format("\n")
		if(getMove(mon.moves[1]) ~= "") then
			str = str .. string.format("- %s\n", getMove(mon.moves[1]))
		end
		if(getMove(mon.moves[2]) ~= "") then
			str = str .. string.format("- %s\n", getMove(mon.moves[2]))
		end
		if(getMove(mon.moves[3]) ~= "") then
			str = str .. string.format("- %s\n", getMove(mon.moves[3]))
		end
		if(getMove(mon.moves[4]) ~= "") then
			str = str .. string.format("- %s\n", getMove(mon.moves[4]))
		end
		str = str .. string.format("\n")
		buffer:print(str)
	end
end

callbacks:add("start", detectGame)
if emu then
	detectGame()
    buffer = console:createBuffer("Monster Hunter Emerald")
	buffer:setSize(200,1000)
  console:log("Monster Hunter Emerald: Use this to pre-status and party export")
	console:log("This script is an adaptation of the Rigorous Red lua made by IndigoNull to work with MHE")
	buffer:print("Available Scripts:\n")
	buffer:print("exportparty() - Exports Party For Calc\n")
	buffer:print("sleep(slot) - Sleeps Pokemon On Your Party\n")
	buffer:print("paralyze(slot) - Paralyzes Pokemon On Your Party\n")
	buffer:print("poison(slot) - Poisons Pokemon On Your Party\n")
	buffer:print("burn(slot) - Burns Pokemon On Your Party\n")
	buffer:print("sethp(slot, hp) - Sets Your Pokemons HP To A Certain Value\n")
	buffer:print("bedtime() - Sets All Your Pokemon To Sleep\n")
	buffer:print("healpp() - Restores PP for all party moves\n")
	buffer:print("healparty() - Fully heals your party (HP + status + PP)\n")
	buffer:print("export() - Exports All Your Pokemon - Some Mons May Not Show Up Due To Nicknames\n")
    -- XP edging helpers removed for MHE
end
